// Code generated by github.com/wubin1989/gen. DO NOT EDIT.
// Code generated by github.com/wubin1989/gen. DO NOT EDIT.
// Code generated by github.com/wubin1989/gen. DO NOT EDIT.

package query

import (
	"context"

	gormgen "github.com/wubin1989/gen"
	"github.com/wubin1989/gorm"
	"github.com/wubin1989/gorm/clause"
	"github.com/wubin1989/gorm/schema"

	"github.com/wubin1989/gen/field"

	"github.com/wubin1989/dbresolver"

	"github.com/go-cinderella/cinderella-engine/engine/internal/model"
)

func newActRuTask(db *gorm.DB, opts ...gormgen.DOOption) actRuTask {
	_actRuTask := actRuTask{}

	_actRuTask.actRuTaskDo.UseDB(db, opts...)
	_actRuTask.actRuTaskDo.UseModel(&model.ActRuTask{})

	tableName := _actRuTask.actRuTaskDo.TableName()
	_actRuTask.ALL = field.NewAsterisk(tableName)
	_actRuTask.ID = field.NewString(tableName, "id_")
	_actRuTask.Rev = field.NewInt32(tableName, "rev_")
	_actRuTask.ExecutionID = field.NewString(tableName, "execution_id_")
	_actRuTask.ProcInstID = field.NewString(tableName, "proc_inst_id_")
	_actRuTask.ProcDefID = field.NewString(tableName, "proc_def_id_")
	_actRuTask.TaskDefID = field.NewString(tableName, "task_def_id_")
	_actRuTask.ScopeID = field.NewString(tableName, "scope_id_")
	_actRuTask.SubScopeID = field.NewString(tableName, "sub_scope_id_")
	_actRuTask.ScopeType = field.NewString(tableName, "scope_type_")
	_actRuTask.ScopeDefinitionID = field.NewString(tableName, "scope_definition_id_")
	_actRuTask.PropagatedStageInstID = field.NewString(tableName, "propagated_stage_inst_id_")
	_actRuTask.Name = field.NewString(tableName, "name_")
	_actRuTask.ParentTaskID = field.NewString(tableName, "parent_task_id_")
	_actRuTask.Description = field.NewString(tableName, "description_")
	_actRuTask.TaskDefKey = field.NewString(tableName, "task_def_key_")
	_actRuTask.Owner = field.NewString(tableName, "owner_")
	_actRuTask.Assignee = field.NewString(tableName, "assignee_")
	_actRuTask.Delegation = field.NewString(tableName, "delegation_")
	_actRuTask.Priority = field.NewInt32(tableName, "priority_")
	_actRuTask.CreateTime = field.NewTime(tableName, "create_time_")
	_actRuTask.DueDate = field.NewTime(tableName, "due_date_")
	_actRuTask.Category = field.NewString(tableName, "category_")
	_actRuTask.SuspensionState = field.NewInt32(tableName, "suspension_state_")
	_actRuTask.TenantID = field.NewString(tableName, "tenant_id_")
	_actRuTask.FormKey = field.NewString(tableName, "form_key_")
	_actRuTask.ClaimTime = field.NewTime(tableName, "claim_time_")
	_actRuTask.IsCountEnabled = field.NewBool(tableName, "is_count_enabled_")
	_actRuTask.VarCount = field.NewInt32(tableName, "var_count_")
	_actRuTask.IDLinkCount = field.NewInt32(tableName, "id_link_count_")
	_actRuTask.SubTaskCount = field.NewInt32(tableName, "sub_task_count_")

	_actRuTask.fillFieldMap()

	return _actRuTask
}

type actRuTask struct {
	 actRuTaskDo

	ALL                   field.Asterisk
	ID                    field.String
	Rev                   field.Int32
	ExecutionID           field.String
	ProcInstID            field.String
	ProcDefID             field.String
	TaskDefID             field.String
	ScopeID               field.String
	SubScopeID            field.String
	ScopeType             field.String
	ScopeDefinitionID     field.String
	PropagatedStageInstID field.String
	Name                  field.String
	ParentTaskID          field.String
	Description           field.String
	TaskDefKey            field.String
	Owner                 field.String
	Assignee              field.String
	Delegation            field.String
	Priority              field.Int32
	CreateTime            field.Time
	DueDate               field.Time
	Category              field.String
	SuspensionState       field.Int32
	TenantID              field.String
	FormKey               field.String
	ClaimTime             field.Time
	IsCountEnabled        field.Bool
	VarCount              field.Int32
	IDLinkCount           field.Int32
	SubTaskCount          field.Int32

	fieldMap map[string]field.Expr
}

func (a actRuTask) Table(newTableName string) *actRuTask {
	a.actRuTaskDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a actRuTask) As(alias string) *actRuTask {
	a.actRuTaskDo.DO = *(a.actRuTaskDo.As(alias).(*gormgen.DO))
	return a.updateTableName(alias)
}

func (a *actRuTask) updateTableName(table string) *actRuTask {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewString(table, "id_")
	a.Rev = field.NewInt32(table, "rev_")
	a.ExecutionID = field.NewString(table, "execution_id_")
	a.ProcInstID = field.NewString(table, "proc_inst_id_")
	a.ProcDefID = field.NewString(table, "proc_def_id_")
	a.TaskDefID = field.NewString(table, "task_def_id_")
	a.ScopeID = field.NewString(table, "scope_id_")
	a.SubScopeID = field.NewString(table, "sub_scope_id_")
	a.ScopeType = field.NewString(table, "scope_type_")
	a.ScopeDefinitionID = field.NewString(table, "scope_definition_id_")
	a.PropagatedStageInstID = field.NewString(table, "propagated_stage_inst_id_")
	a.Name = field.NewString(table, "name_")
	a.ParentTaskID = field.NewString(table, "parent_task_id_")
	a.Description = field.NewString(table, "description_")
	a.TaskDefKey = field.NewString(table, "task_def_key_")
	a.Owner = field.NewString(table, "owner_")
	a.Assignee = field.NewString(table, "assignee_")
	a.Delegation = field.NewString(table, "delegation_")
	a.Priority = field.NewInt32(table, "priority_")
	a.CreateTime = field.NewTime(table, "create_time_")
	a.DueDate = field.NewTime(table, "due_date_")
	a.Category = field.NewString(table, "category_")
	a.SuspensionState = field.NewInt32(table, "suspension_state_")
	a.TenantID = field.NewString(table, "tenant_id_")
	a.FormKey = field.NewString(table, "form_key_")
	a.ClaimTime = field.NewTime(table, "claim_time_")
	a.IsCountEnabled = field.NewBool(table, "is_count_enabled_")
	a.VarCount = field.NewInt32(table, "var_count_")
	a.IDLinkCount = field.NewInt32(table, "id_link_count_")
	a.SubTaskCount = field.NewInt32(table, "sub_task_count_")

	a.fillFieldMap()

	return a
}

func (a *actRuTask) WithContext(ctx context.Context) IActRuTaskDo {
	return a.actRuTaskDo.WithContext(ctx)
}

func (a actRuTask) TableName() string { return a.actRuTaskDo.TableName() }

func (a actRuTask) Alias() string { return a.actRuTaskDo.Alias() }

func (a actRuTask) Columns(cols ...field.Expr) gormgen.Columns { return a.actRuTaskDo.Columns(cols...) }

func (a *actRuTask) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *actRuTask) GetFieldExprByName(fieldName string) (field.Expr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	return _f, ok
}

func (a *actRuTask) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 30)
	a.fieldMap["id_"] = a.ID
	a.fieldMap["rev_"] = a.Rev
	a.fieldMap["execution_id_"] = a.ExecutionID
	a.fieldMap["proc_inst_id_"] = a.ProcInstID
	a.fieldMap["proc_def_id_"] = a.ProcDefID
	a.fieldMap["task_def_id_"] = a.TaskDefID
	a.fieldMap["scope_id_"] = a.ScopeID
	a.fieldMap["sub_scope_id_"] = a.SubScopeID
	a.fieldMap["scope_type_"] = a.ScopeType
	a.fieldMap["scope_definition_id_"] = a.ScopeDefinitionID
	a.fieldMap["propagated_stage_inst_id_"] = a.PropagatedStageInstID
	a.fieldMap["name_"] = a.Name
	a.fieldMap["parent_task_id_"] = a.ParentTaskID
	a.fieldMap["description_"] = a.Description
	a.fieldMap["task_def_key_"] = a.TaskDefKey
	a.fieldMap["owner_"] = a.Owner
	a.fieldMap["assignee_"] = a.Assignee
	a.fieldMap["delegation_"] = a.Delegation
	a.fieldMap["priority_"] = a.Priority
	a.fieldMap["create_time_"] = a.CreateTime
	a.fieldMap["due_date_"] = a.DueDate
	a.fieldMap["category_"] = a.Category
	a.fieldMap["suspension_state_"] = a.SuspensionState
	a.fieldMap["tenant_id_"] = a.TenantID
	a.fieldMap["form_key_"] = a.FormKey
	a.fieldMap["claim_time_"] = a.ClaimTime
	a.fieldMap["is_count_enabled_"] = a.IsCountEnabled
	a.fieldMap["var_count_"] = a.VarCount
	a.fieldMap["id_link_count_"] = a.IDLinkCount
	a.fieldMap["sub_task_count_"] = a.SubTaskCount
}

func (a actRuTask) Clone(db *gorm.DB) actRuTask {
	a.actRuTaskDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a actRuTask) ReplaceDB(db *gorm.DB) actRuTask {
	a.actRuTaskDo.ReplaceDB(db)
	return a
}

type actRuTaskDo struct{ gormgen.DO }

type IActRuTaskDo interface {
	gormgen.SubQuery
	Debug() IActRuTaskDo
	WithContext(ctx context.Context) IActRuTaskDo
	WithResult(fc func(tx gormgen.Dao)) gormgen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IActRuTaskDo
	WriteDB() IActRuTaskDo
	As(alias string) gormgen.Dao
	Session(config *gorm.Session) IActRuTaskDo
	Columns(cols ...field.Expr) gormgen.Columns
	Clauses(conds ...clause.Expression) IActRuTaskDo
	Not(conds ...gormgen.Condition) IActRuTaskDo
	Or(conds ...gormgen.Condition) IActRuTaskDo
	Select(conds ...field.Expr) IActRuTaskDo
	Where(conds ...gormgen.Condition) IActRuTaskDo
	Order(conds ...field.Expr) IActRuTaskDo
	Distinct(cols ...field.Expr) IActRuTaskDo
	Omit(cols ...field.Expr) IActRuTaskDo
	Join(table schema.Tabler, on ...field.Expr) IActRuTaskDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IActRuTaskDo
	RightJoin(table schema.Tabler, on ...field.Expr) IActRuTaskDo
	Group(cols ...field.Expr) IActRuTaskDo
	Having(conds ...gormgen.Condition) IActRuTaskDo
	Limit(limit int) IActRuTaskDo
	Offset(offset int) IActRuTaskDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IActRuTaskDo
	Unscoped() IActRuTaskDo
	Create(values ...*model.ActRuTask) error
	CreateInBatches(values []*model.ActRuTask, batchSize int) error
	Save(values ...*model.ActRuTask) error
	First() (*model.ActRuTask, error)
	Take() (*model.ActRuTask, error)
	Last() (*model.ActRuTask, error)
	Find() ([]*model.ActRuTask, error)
	FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.ActRuTask, err error)
	FindInBatches(result *[]*model.ActRuTask, batchSize int, fc func(tx gormgen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ActRuTask) (info gormgen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	Updates(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateFrom(q gormgen.SubQuery) gormgen.Dao
	Attrs(attrs ...field.AssignExpr) IActRuTaskDo
	Assign(attrs ...field.AssignExpr) IActRuTaskDo
	Joins(fields ...field.RelationField) IActRuTaskDo
	Preload(fields ...field.RelationField) IActRuTaskDo
	FirstOrInit() (*model.ActRuTask, error)
	FirstOrCreate() (*model.ActRuTask, error)
	FindByPage(offset int, limit int) (result []*model.ActRuTask, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Fetch(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IActRuTaskDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a actRuTaskDo) Debug() IActRuTaskDo {
	return a.withDO(a.DO.Debug())
}

func (a actRuTaskDo) WithContext(ctx context.Context) IActRuTaskDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a actRuTaskDo) ReadDB() IActRuTaskDo {
	return a.Clauses(dbresolver.Read)
}

func (a actRuTaskDo) WriteDB() IActRuTaskDo {
	return a.Clauses(dbresolver.Write)
}

func (a actRuTaskDo) Session(config *gorm.Session) IActRuTaskDo {
	return a.withDO(a.DO.Session(config))
}

func (a actRuTaskDo) Clauses(conds ...clause.Expression) IActRuTaskDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a actRuTaskDo) Returning(value interface{}, columns ...string) IActRuTaskDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a actRuTaskDo) Not(conds ...gormgen.Condition) IActRuTaskDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a actRuTaskDo) Or(conds ...gormgen.Condition) IActRuTaskDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a actRuTaskDo) Select(conds ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a actRuTaskDo) Where(conds ...gormgen.Condition) IActRuTaskDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a actRuTaskDo) Order(conds ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a actRuTaskDo) Distinct(cols ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a actRuTaskDo) Omit(cols ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a actRuTaskDo) Join(table schema.Tabler, on ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a actRuTaskDo) LeftJoin(table schema.Tabler, on ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a actRuTaskDo) RightJoin(table schema.Tabler, on ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a actRuTaskDo) Group(cols ...field.Expr) IActRuTaskDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a actRuTaskDo) Having(conds ...gormgen.Condition) IActRuTaskDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a actRuTaskDo) Limit(limit int) IActRuTaskDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a actRuTaskDo) Offset(offset int) IActRuTaskDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a actRuTaskDo) Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IActRuTaskDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a actRuTaskDo) Unscoped() IActRuTaskDo {
	return a.withDO(a.DO.Unscoped())
}

func (a actRuTaskDo) Create(values ...*model.ActRuTask) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a actRuTaskDo) CreateInBatches(values []*model.ActRuTask, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a actRuTaskDo) Save(values ...*model.ActRuTask) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a actRuTaskDo) First() (*model.ActRuTask, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuTask), nil
	}
}

func (a actRuTaskDo) Take() (*model.ActRuTask, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuTask), nil
	}
}

func (a actRuTaskDo) Last() (*model.ActRuTask, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuTask), nil
	}
}

func (a actRuTaskDo) Find() ([]*model.ActRuTask, error) {
	result, err := a.DO.Find()
	return result.([]*model.ActRuTask), err
}

func (a actRuTaskDo) FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.ActRuTask, err error) {
	buf := make([]*model.ActRuTask, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gormgen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a actRuTaskDo) FindInBatches(result *[]*model.ActRuTask, batchSize int, fc func(tx gormgen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a actRuTaskDo) Attrs(attrs ...field.AssignExpr) IActRuTaskDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a actRuTaskDo) Assign(attrs ...field.AssignExpr) IActRuTaskDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a actRuTaskDo) Joins(fields ...field.RelationField) IActRuTaskDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a actRuTaskDo) Preload(fields ...field.RelationField) IActRuTaskDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a actRuTaskDo) FirstOrInit() (*model.ActRuTask, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuTask), nil
	}
}

func (a actRuTaskDo) FirstOrCreate() (*model.ActRuTask, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuTask), nil
	}
}

func (a actRuTaskDo) FindByPage(offset int, limit int) (result []*model.ActRuTask, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a actRuTaskDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a actRuTaskDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a actRuTaskDo) Fetch(result interface{}) (err error) {
	return a.DO.Fetch(result)
}

func (a actRuTaskDo) Delete(models ...*model.ActRuTask) (result gormgen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *actRuTaskDo) withDO(do gormgen.Dao) *actRuTaskDo {
	a.DO = *do.(*gormgen.DO)
	return a
}

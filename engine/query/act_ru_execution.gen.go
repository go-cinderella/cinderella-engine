// Code generated by github.com/wubin1989/gen. DO NOT EDIT.
// Code generated by github.com/wubin1989/gen. DO NOT EDIT.
// Code generated by github.com/wubin1989/gen. DO NOT EDIT.

package query

import (
	"context"

	gormgen "github.com/wubin1989/gen"
	"github.com/wubin1989/gorm"
	"github.com/wubin1989/gorm/clause"
	"github.com/wubin1989/gorm/schema"

	"github.com/wubin1989/gen/field"

	"github.com/wubin1989/dbresolver"

	"github.com/go-cinderella/cinderella-engine/engine/internal/model"
)

func newActRuExecution(db *gorm.DB, opts ...gormgen.DOOption) actRuExecution {
	_actRuExecution := actRuExecution{}

	_actRuExecution.actRuExecutionDo.UseDB(db, opts...)
	_actRuExecution.actRuExecutionDo.UseModel(&model.ActRuExecution{})

	tableName := _actRuExecution.actRuExecutionDo.TableName()
	_actRuExecution.ALL = field.NewAsterisk(tableName)
	_actRuExecution.ID = field.NewString(tableName, "id_")
	_actRuExecution.Rev = field.NewInt32(tableName, "rev_")
	_actRuExecution.ProcInstID = field.NewString(tableName, "proc_inst_id_")
	_actRuExecution.BusinessKey = field.NewString(tableName, "business_key_")
	_actRuExecution.ParentID = field.NewString(tableName, "parent_id_")
	_actRuExecution.ProcDefID = field.NewString(tableName, "proc_def_id_")
	_actRuExecution.SuperExec = field.NewString(tableName, "super_exec_")
	_actRuExecution.RootProcInstID = field.NewString(tableName, "root_proc_inst_id_")
	_actRuExecution.ActID = field.NewString(tableName, "act_id_")
	_actRuExecution.IsActive = field.NewBool(tableName, "is_active_")
	_actRuExecution.IsConcurrent = field.NewBool(tableName, "is_concurrent_")
	_actRuExecution.IsScope = field.NewBool(tableName, "is_scope_")
	_actRuExecution.IsEventScope = field.NewBool(tableName, "is_event_scope_")
	_actRuExecution.IsMiRoot = field.NewBool(tableName, "is_mi_root_")
	_actRuExecution.SuspensionState = field.NewInt32(tableName, "suspension_state_")
	_actRuExecution.CachedEntState = field.NewInt32(tableName, "cached_ent_state_")
	_actRuExecution.TenantID = field.NewString(tableName, "tenant_id_")
	_actRuExecution.Name = field.NewString(tableName, "name_")
	_actRuExecution.StartActID = field.NewString(tableName, "start_act_id_")
	_actRuExecution.StartTime = field.NewTime(tableName, "start_time_")
	_actRuExecution.StartUserID = field.NewString(tableName, "start_user_id_")
	_actRuExecution.LockTime = field.NewTime(tableName, "lock_time_")
	_actRuExecution.LockOwner = field.NewString(tableName, "lock_owner_")
	_actRuExecution.IsCountEnabled = field.NewBool(tableName, "is_count_enabled_")
	_actRuExecution.EvtSubscrCount = field.NewInt32(tableName, "evt_subscr_count_")
	_actRuExecution.TaskCount = field.NewInt32(tableName, "task_count_")
	_actRuExecution.JobCount = field.NewInt32(tableName, "job_count_")
	_actRuExecution.TimerJobCount = field.NewInt32(tableName, "timer_job_count_")
	_actRuExecution.SuspJobCount = field.NewInt32(tableName, "susp_job_count_")
	_actRuExecution.DeadletterJobCount = field.NewInt32(tableName, "deadletter_job_count_")
	_actRuExecution.ExternalWorkerJobCount = field.NewInt32(tableName, "external_worker_job_count_")
	_actRuExecution.VarCount = field.NewInt32(tableName, "var_count_")
	_actRuExecution.IDLinkCount = field.NewInt32(tableName, "id_link_count_")
	_actRuExecution.CallbackID = field.NewString(tableName, "callback_id_")
	_actRuExecution.CallbackType = field.NewString(tableName, "callback_type_")
	_actRuExecution.ReferenceID = field.NewString(tableName, "reference_id_")
	_actRuExecution.ReferenceType = field.NewString(tableName, "reference_type_")
	_actRuExecution.PropagatedStageInstID = field.NewString(tableName, "propagated_stage_inst_id_")
	_actRuExecution.BusinessStatus = field.NewString(tableName, "business_status_")

	_actRuExecution.fillFieldMap()

	return _actRuExecution
}

type actRuExecution struct {
	 actRuExecutionDo

	ALL                    field.Asterisk
	ID                     field.String
	Rev                    field.Int32
	ProcInstID             field.String
	BusinessKey            field.String
	ParentID               field.String
	ProcDefID              field.String
	SuperExec              field.String
	RootProcInstID         field.String
	ActID                  field.String
	IsActive               field.Bool
	IsConcurrent           field.Bool
	IsScope                field.Bool
	IsEventScope           field.Bool
	IsMiRoot               field.Bool
	SuspensionState        field.Int32
	CachedEntState         field.Int32
	TenantID               field.String
	Name                   field.String
	StartActID             field.String
	StartTime              field.Time
	StartUserID            field.String
	LockTime               field.Time
	LockOwner              field.String
	IsCountEnabled         field.Bool
	EvtSubscrCount         field.Int32
	TaskCount              field.Int32
	JobCount               field.Int32
	TimerJobCount          field.Int32
	SuspJobCount           field.Int32
	DeadletterJobCount     field.Int32
	ExternalWorkerJobCount field.Int32
	VarCount               field.Int32
	IDLinkCount            field.Int32
	CallbackID             field.String
	CallbackType           field.String
	ReferenceID            field.String
	ReferenceType          field.String
	PropagatedStageInstID  field.String
	BusinessStatus         field.String

	fieldMap map[string]field.Expr
}

func (a actRuExecution) Table(newTableName string) *actRuExecution {
	a.actRuExecutionDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a actRuExecution) As(alias string) *actRuExecution {
	a.actRuExecutionDo.DO = *(a.actRuExecutionDo.As(alias).(*gormgen.DO))
	return a.updateTableName(alias)
}

func (a *actRuExecution) updateTableName(table string) *actRuExecution {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewString(table, "id_")
	a.Rev = field.NewInt32(table, "rev_")
	a.ProcInstID = field.NewString(table, "proc_inst_id_")
	a.BusinessKey = field.NewString(table, "business_key_")
	a.ParentID = field.NewString(table, "parent_id_")
	a.ProcDefID = field.NewString(table, "proc_def_id_")
	a.SuperExec = field.NewString(table, "super_exec_")
	a.RootProcInstID = field.NewString(table, "root_proc_inst_id_")
	a.ActID = field.NewString(table, "act_id_")
	a.IsActive = field.NewBool(table, "is_active_")
	a.IsConcurrent = field.NewBool(table, "is_concurrent_")
	a.IsScope = field.NewBool(table, "is_scope_")
	a.IsEventScope = field.NewBool(table, "is_event_scope_")
	a.IsMiRoot = field.NewBool(table, "is_mi_root_")
	a.SuspensionState = field.NewInt32(table, "suspension_state_")
	a.CachedEntState = field.NewInt32(table, "cached_ent_state_")
	a.TenantID = field.NewString(table, "tenant_id_")
	a.Name = field.NewString(table, "name_")
	a.StartActID = field.NewString(table, "start_act_id_")
	a.StartTime = field.NewTime(table, "start_time_")
	a.StartUserID = field.NewString(table, "start_user_id_")
	a.LockTime = field.NewTime(table, "lock_time_")
	a.LockOwner = field.NewString(table, "lock_owner_")
	a.IsCountEnabled = field.NewBool(table, "is_count_enabled_")
	a.EvtSubscrCount = field.NewInt32(table, "evt_subscr_count_")
	a.TaskCount = field.NewInt32(table, "task_count_")
	a.JobCount = field.NewInt32(table, "job_count_")
	a.TimerJobCount = field.NewInt32(table, "timer_job_count_")
	a.SuspJobCount = field.NewInt32(table, "susp_job_count_")
	a.DeadletterJobCount = field.NewInt32(table, "deadletter_job_count_")
	a.ExternalWorkerJobCount = field.NewInt32(table, "external_worker_job_count_")
	a.VarCount = field.NewInt32(table, "var_count_")
	a.IDLinkCount = field.NewInt32(table, "id_link_count_")
	a.CallbackID = field.NewString(table, "callback_id_")
	a.CallbackType = field.NewString(table, "callback_type_")
	a.ReferenceID = field.NewString(table, "reference_id_")
	a.ReferenceType = field.NewString(table, "reference_type_")
	a.PropagatedStageInstID = field.NewString(table, "propagated_stage_inst_id_")
	a.BusinessStatus = field.NewString(table, "business_status_")

	a.fillFieldMap()

	return a
}

func (a *actRuExecution) WithContext(ctx context.Context) IActRuExecutionDo {
	return a.actRuExecutionDo.WithContext(ctx)
}

func (a actRuExecution) TableName() string { return a.actRuExecutionDo.TableName() }

func (a actRuExecution) Alias() string { return a.actRuExecutionDo.Alias() }

func (a actRuExecution) Columns(cols ...field.Expr) gormgen.Columns {
	return a.actRuExecutionDo.Columns(cols...)
}

func (a *actRuExecution) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *actRuExecution) GetFieldExprByName(fieldName string) (field.Expr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	return _f, ok
}

func (a *actRuExecution) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 39)
	a.fieldMap["id_"] = a.ID
	a.fieldMap["rev_"] = a.Rev
	a.fieldMap["proc_inst_id_"] = a.ProcInstID
	a.fieldMap["business_key_"] = a.BusinessKey
	a.fieldMap["parent_id_"] = a.ParentID
	a.fieldMap["proc_def_id_"] = a.ProcDefID
	a.fieldMap["super_exec_"] = a.SuperExec
	a.fieldMap["root_proc_inst_id_"] = a.RootProcInstID
	a.fieldMap["act_id_"] = a.ActID
	a.fieldMap["is_active_"] = a.IsActive
	a.fieldMap["is_concurrent_"] = a.IsConcurrent
	a.fieldMap["is_scope_"] = a.IsScope
	a.fieldMap["is_event_scope_"] = a.IsEventScope
	a.fieldMap["is_mi_root_"] = a.IsMiRoot
	a.fieldMap["suspension_state_"] = a.SuspensionState
	a.fieldMap["cached_ent_state_"] = a.CachedEntState
	a.fieldMap["tenant_id_"] = a.TenantID
	a.fieldMap["name_"] = a.Name
	a.fieldMap["start_act_id_"] = a.StartActID
	a.fieldMap["start_time_"] = a.StartTime
	a.fieldMap["start_user_id_"] = a.StartUserID
	a.fieldMap["lock_time_"] = a.LockTime
	a.fieldMap["lock_owner_"] = a.LockOwner
	a.fieldMap["is_count_enabled_"] = a.IsCountEnabled
	a.fieldMap["evt_subscr_count_"] = a.EvtSubscrCount
	a.fieldMap["task_count_"] = a.TaskCount
	a.fieldMap["job_count_"] = a.JobCount
	a.fieldMap["timer_job_count_"] = a.TimerJobCount
	a.fieldMap["susp_job_count_"] = a.SuspJobCount
	a.fieldMap["deadletter_job_count_"] = a.DeadletterJobCount
	a.fieldMap["external_worker_job_count_"] = a.ExternalWorkerJobCount
	a.fieldMap["var_count_"] = a.VarCount
	a.fieldMap["id_link_count_"] = a.IDLinkCount
	a.fieldMap["callback_id_"] = a.CallbackID
	a.fieldMap["callback_type_"] = a.CallbackType
	a.fieldMap["reference_id_"] = a.ReferenceID
	a.fieldMap["reference_type_"] = a.ReferenceType
	a.fieldMap["propagated_stage_inst_id_"] = a.PropagatedStageInstID
	a.fieldMap["business_status_"] = a.BusinessStatus
}

func (a actRuExecution) Clone(db *gorm.DB) actRuExecution {
	a.actRuExecutionDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a actRuExecution) ReplaceDB(db *gorm.DB) actRuExecution {
	a.actRuExecutionDo.ReplaceDB(db)
	return a
}

type actRuExecutionDo struct{ gormgen.DO }

type IActRuExecutionDo interface {
	gormgen.SubQuery
	Debug() IActRuExecutionDo
	WithContext(ctx context.Context) IActRuExecutionDo
	WithResult(fc func(tx gormgen.Dao)) gormgen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IActRuExecutionDo
	WriteDB() IActRuExecutionDo
	As(alias string) gormgen.Dao
	Session(config *gorm.Session) IActRuExecutionDo
	Columns(cols ...field.Expr) gormgen.Columns
	Clauses(conds ...clause.Expression) IActRuExecutionDo
	Not(conds ...gormgen.Condition) IActRuExecutionDo
	Or(conds ...gormgen.Condition) IActRuExecutionDo
	Select(conds ...field.Expr) IActRuExecutionDo
	Where(conds ...gormgen.Condition) IActRuExecutionDo
	Order(conds ...field.Expr) IActRuExecutionDo
	Distinct(cols ...field.Expr) IActRuExecutionDo
	Omit(cols ...field.Expr) IActRuExecutionDo
	Join(table schema.Tabler, on ...field.Expr) IActRuExecutionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IActRuExecutionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IActRuExecutionDo
	Group(cols ...field.Expr) IActRuExecutionDo
	Having(conds ...gormgen.Condition) IActRuExecutionDo
	Limit(limit int) IActRuExecutionDo
	Offset(offset int) IActRuExecutionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IActRuExecutionDo
	Unscoped() IActRuExecutionDo
	Create(values ...*model.ActRuExecution) error
	CreateInBatches(values []*model.ActRuExecution, batchSize int) error
	Save(values ...*model.ActRuExecution) error
	First() (*model.ActRuExecution, error)
	Take() (*model.ActRuExecution, error)
	Last() (*model.ActRuExecution, error)
	Find() ([]*model.ActRuExecution, error)
	FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.ActRuExecution, err error)
	FindInBatches(result *[]*model.ActRuExecution, batchSize int, fc func(tx gormgen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ActRuExecution) (info gormgen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	Updates(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateFrom(q gormgen.SubQuery) gormgen.Dao
	Attrs(attrs ...field.AssignExpr) IActRuExecutionDo
	Assign(attrs ...field.AssignExpr) IActRuExecutionDo
	Joins(fields ...field.RelationField) IActRuExecutionDo
	Preload(fields ...field.RelationField) IActRuExecutionDo
	FirstOrInit() (*model.ActRuExecution, error)
	FirstOrCreate() (*model.ActRuExecution, error)
	FindByPage(offset int, limit int) (result []*model.ActRuExecution, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Fetch(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IActRuExecutionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a actRuExecutionDo) Debug() IActRuExecutionDo {
	return a.withDO(a.DO.Debug())
}

func (a actRuExecutionDo) WithContext(ctx context.Context) IActRuExecutionDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a actRuExecutionDo) ReadDB() IActRuExecutionDo {
	return a.Clauses(dbresolver.Read)
}

func (a actRuExecutionDo) WriteDB() IActRuExecutionDo {
	return a.Clauses(dbresolver.Write)
}

func (a actRuExecutionDo) Session(config *gorm.Session) IActRuExecutionDo {
	return a.withDO(a.DO.Session(config))
}

func (a actRuExecutionDo) Clauses(conds ...clause.Expression) IActRuExecutionDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a actRuExecutionDo) Returning(value interface{}, columns ...string) IActRuExecutionDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a actRuExecutionDo) Not(conds ...gormgen.Condition) IActRuExecutionDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a actRuExecutionDo) Or(conds ...gormgen.Condition) IActRuExecutionDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a actRuExecutionDo) Select(conds ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a actRuExecutionDo) Where(conds ...gormgen.Condition) IActRuExecutionDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a actRuExecutionDo) Order(conds ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a actRuExecutionDo) Distinct(cols ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a actRuExecutionDo) Omit(cols ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a actRuExecutionDo) Join(table schema.Tabler, on ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a actRuExecutionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a actRuExecutionDo) RightJoin(table schema.Tabler, on ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a actRuExecutionDo) Group(cols ...field.Expr) IActRuExecutionDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a actRuExecutionDo) Having(conds ...gormgen.Condition) IActRuExecutionDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a actRuExecutionDo) Limit(limit int) IActRuExecutionDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a actRuExecutionDo) Offset(offset int) IActRuExecutionDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a actRuExecutionDo) Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IActRuExecutionDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a actRuExecutionDo) Unscoped() IActRuExecutionDo {
	return a.withDO(a.DO.Unscoped())
}

func (a actRuExecutionDo) Create(values ...*model.ActRuExecution) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a actRuExecutionDo) CreateInBatches(values []*model.ActRuExecution, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a actRuExecutionDo) Save(values ...*model.ActRuExecution) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a actRuExecutionDo) First() (*model.ActRuExecution, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuExecution), nil
	}
}

func (a actRuExecutionDo) Take() (*model.ActRuExecution, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuExecution), nil
	}
}

func (a actRuExecutionDo) Last() (*model.ActRuExecution, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuExecution), nil
	}
}

func (a actRuExecutionDo) Find() ([]*model.ActRuExecution, error) {
	result, err := a.DO.Find()
	return result.([]*model.ActRuExecution), err
}

func (a actRuExecutionDo) FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.ActRuExecution, err error) {
	buf := make([]*model.ActRuExecution, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gormgen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a actRuExecutionDo) FindInBatches(result *[]*model.ActRuExecution, batchSize int, fc func(tx gormgen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a actRuExecutionDo) Attrs(attrs ...field.AssignExpr) IActRuExecutionDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a actRuExecutionDo) Assign(attrs ...field.AssignExpr) IActRuExecutionDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a actRuExecutionDo) Joins(fields ...field.RelationField) IActRuExecutionDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a actRuExecutionDo) Preload(fields ...field.RelationField) IActRuExecutionDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a actRuExecutionDo) FirstOrInit() (*model.ActRuExecution, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuExecution), nil
	}
}

func (a actRuExecutionDo) FirstOrCreate() (*model.ActRuExecution, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActRuExecution), nil
	}
}

func (a actRuExecutionDo) FindByPage(offset int, limit int) (result []*model.ActRuExecution, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a actRuExecutionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a actRuExecutionDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a actRuExecutionDo) Fetch(result interface{}) (err error) {
	return a.DO.Fetch(result)
}

func (a actRuExecutionDo) Delete(models ...*model.ActRuExecution) (result gormgen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *actRuExecutionDo) withDO(do gormgen.Dao) *actRuExecutionDo {
	a.DO = *do.(*gormgen.DO)
	return a
}
